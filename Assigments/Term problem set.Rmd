---
title: "Term problem set"
author: "Alyssa Vanderbeek (amv2187)"
date: "2 December 2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

library(tidyverse)
library(dfcrm)
```


### Problem 1: (Preliminaries) For a randomized, placebo-controlled study of a statin for lowering LDL, we consider a reduction in LDL by 10mg/dL on average to be clinically meaningful, whereas patients in the placebo will experience no change on average. Assume that the variance of LDL is equal to 20mg/dL at both baseline and the 3-month follow-up in both groups.

### a. What additional information or assumption(s) do you need to calculate a sample size?

We need to know the following in order to compute a sample size:
* target type I error rate and power
* the average LDL level in the placebo group 

### b. State the assumptions you make and calculate the sample size required for a two-sided test at 5\% significance.

Let's suppose that \alpha=0.05 and target power is 90\%. Consider that the population LDL is approximately normally distributed.

Since the primary outcome is the difference in differences between the two groups, we also have to make assumptions about the correlation between the measurements in each group at baseline and 3 months. I used simulation to estimate a reasonable correlation between the paired measurements in each treatment group. 

```{r 1_cor}
n.sim = 1e3

d.null = 0
d.alt = 10
var = 20

ldl.null = 145
ldl.alt = ldl.null - d.alt

cor_sim = function(ldl, d, var, vals = FALSE){
  p_base = rnorm(1e3, ldl, sqrt(var))
  add = rnorm(1e3, d, sqrt(var))
  p_3 = p_base - add
  
  if (vals == TRUE) {
    return(list(c = cor(p_base, p_3),
                p_base = p_base,
                p_3 = p_3))
  } else {
    return(cor(p_base, p_3))
  }
}

placebo = cor_sim(ldl = ldl.null, d = d.null, var = var, vals = TRUE)
exp = cor_sim(ldl = ldl.null, d = d.alt, var = var, vals = TRUE)

par(mfrow = c(1, 2))
plot(x = placebo$p_base, y = placebo$p_3,
     xlab = "Baseline LDL", ylab = "3 month LDL", main = "Placebo",
     xlim = c(120, 170), ylim = c(120, 170))
plot(x = exp$p_base, y = exp$p_3,
     xlab = "Baseline LDL", ylab = "3 month LDL", main = "Experimental",
     xlim = c(120, 170), ylim = c(120, 170))


cor_placebo = sapply(X = 1:n.sim, function(i){ 
  cor_sim(ldl = ldl.null, d = d.null, var = var)
})
mean(cor_placebo)
cor_exp = sapply(X = 1:n.sim, function(i){ 
  cor_sim(ldl = ldl.null, d = d.alt, var = var)
})
mean(cor_exp)
```

Based on these simulations, it's reasonable to assume that the correlation between baseline and 3-month measurements in both groups is ~0.7. Then the distributions of the differences in each treatment group are

$$
d &\sim N(E(\mu_{\text{base}} - \mu_{\text{3mo}}), Var(\mu_{\text{base}} - \mu_{\text{3mo}})) \\
&\sim N(E(\mu_{\text{base}}) + E(\mu_{\text{3mo}}), Var(\mu_{\text{base}}) + Var(\mu_{\text{3mo}}) - 2Cor(\mu_{\text{base}}, \mu_{\text{3mo}}) sd(\mu_{\text{base}}) sd(\mu_{\text{3mo}})) \\
&\sim N(0, \sigma^2 + \sigma^2 - (2)(0.7)(\sigma^2))) \\
&\sim N(0, 1.6\sigma^2)
$$

Even though are assumed to know the population variance in LDL, it may be most appropriate to conduct a t-test. This may be especially appropriate for small sample sizes (n<30 in each group), where we cannot assume the observed data are normally distributed. Again, using simulations to find the sample sizes that corresponds to a type I error of at most 0.05, and power of at least 0.9:

```{r 1_n}
alpha = 0.05
pow.target = 0.9

## Function to find sample size that meets target alpha and power
ss_calc = function(target_alpha, target_pow, null, alt, var) {
  i = 2
  t1 = 0.5
  pow = 0.5
  while (pow < target_pow || t1 > target_alpha) { # do I need to make sure that type I error is also below target?
    
    ## Under null hypothesis
    h.null = sapply(1:n.sim, function(j) {
      placebo = rnorm(i, null, sqrt(0.6*var))
      exp.null = rnorm(i, null, sqrt(0.6*var))
      
      return(t.test(exp.null, placebo, alternative = "greater", var.equal = TRUE)[[1]])
    })
    
    ## Under alternative hypothesis
    h.alt = sapply(1:n.sim, function(j) {
      placebo = rnorm(i, null, sqrt(0.6*var))
      exp.alt = rnorm(i, alt, sqrt(0.6*var))
      
      return(t.test(exp.alt, placebo, alternative = "greater", var.equal = TRUE)[[1]])
      #return((mean(exp.alt) - mean(placebo)) / sqrt(((2.6*var))/(2*i)))
    })
    
    # simulated type I error and power
    t1 = mean(h.null >= qt(1 - target_alpha, df = 2*i - 1)) # test for greater than critical value since reduction is taken as a positive value
    pow = mean(h.alt >= qt(1 - target_alpha, df = 2*i - 1))
    
    #print(c("n" = i, "type 1" = t1, "power" = pow))
    i = i + 1
  }
  
  return(i - 1)
}

# simulate 200 times
set.seed(1)
t = sapply(1:200, function(i){
  ss_calc(target_alpha = alpha, 
          target_pow = pow.target, 
          null = d.null, 
          alt = d.alt, 
          var = var)
})
mean(t) # average number of subjects 
```

Rounding up, a sample size of `r ceiling(mean(t))` in each group is appropriate.


### Problem 2: (Go/no-go) In a two-stage trial of an experimental treatment with a planned futility interim analysis, 14 patients are first enrolled and treated in the first stage. An additional of 20 patients will be enrolled and treated if there is at least 1 response in the first stage. At the end of the trial, the treatment is deemed promising ("go") when there are at least 4 responses in all enrolled patients.

### a. Suppose the true response rate is 5\%. What is the expected value of the sample size?

```{r 2a}
p = 0.05
n1 = 14
e1 = 1
ntotal = 34
e2 = 4
n2 = ntotal - n1

# P(stopping at stage 1 | p = 0.05)
x = pbinom(e1 - 1, n1, p) # 0.48

# Expected sample size
n_expected = ceiling(n1*x + ntotal*(1 - x)) # 24.24

```

For a true response rate of 5\%, the expected sample size of the trial is 25 subjects. 

### b. Suppose the true response rate is 5\%. Evaluate the probability of a "go" decision.

```{r 2b}
f = c()
for (i in e1:n1) {
  f[i] = dbinom(i, n1, p) * (1 - pbinom(e2 - i - 1, n2, p))
}
pgo1 = sum(f, na.rm = T)
```

The probability of a "go" decision is given by 
\begin{align*}
Pr(go) &= Pr(S_{14} \geq 1, S_{34} \geq 4 | p = 0.05) \\
&= ... = \Sigma_{n=1}^{14} [Pr(S_14 = n|p = 0.05) * \Sigma_{m = n}^{34} [Pr(S_{20} 
\geq 4-m | p = 0.05)]].
\end{align*}

For a true response rate of 5\%, the probability of a "go" decision is ~0.08.

### c. Suppose the true response rate is 20\%. Evaluate the probability of a "go" decision.

```{r 2c}
p = 0.2
f = c()
for (i in e1:n1) {
  f[i] = dbinom(i, n1, p) * (1 - pbinom(e2 - i - 1, n2, p))
}
pgo2 = sum(f, na.rm = T)
```

Using the same formulation for calculating $Pr(go)$ as above, for a true response rate of 20\%, the probability of making a "go" decision is ~0.90.

### d. Using your result in (b) as type I error rate and (c) as power, evaluate the sample size required for a fixed design with null response 5\% and alternative response 20\%.
```{r 2d}
p0 = 0.05
p1 = 0.2
alpha = pgo1
power = pgo2

ss = list()
for (i in 1:50) {
  n = i
  s = seq(1, i, 1)
  
  t1 = 1 - pbinom(s - 1, n, p0)
  pow = 1 - pbinom(s - 1, n, p1)
  index = intersect(which(t1 <= alpha), which(pow >= power))
  
  if (length(index) == 0) {
    ss[[i]] = NA
  } else {
    ss[[i]] = c(s[index[1]], n)
  }
}

n = ss[which(!is.na(ss))[1]][[1]][2]
s = ss[which(!is.na(ss))[1]][[1]][1]


```

Setting type I error to 0.08 and power to 0.90, we find that the sample size required for a fixed design is `r n` subjects, for which we reject the null in favor of the alternative when we see a response from at least `r s`. 


## Problem 3: (Predictive distribution) Suppose X1 follows an exponential distribution with rate .

### a. Give a conjugate prior for Derive its posterior distribution and the corresponding prior predictive distribution of X1.

### b. Suppose X1 and X2 are exchangeable. Derive the posterior predictive distribution of X2 given X1.

### c. Derive the posterior predictive distribution of (X1 + X2)/2 given X1.


## Problem 4: Suppose the toxicity probability of dose level 1 is 0.25. Calculate the probability that the 3+3 algorithm will declare dose level 1 safe (i.e., below the MTD).


```{r 4}
p = dbinom(0, 3, 0.25) + dbinom(1, 6,0.25)*dbinom(1, 3, 0.25)
```

With a toxicity probability of 0.25, the 3+3 algorithm will declare dose safe (i.e. at or below the MTD) with probability `r round(p, 2)`.

## Problem 5: 

### (a) 
```{r fn_3p3}

variate_3plus3 = function(coh.size, dlt, variates, start = NULL) {
  
  # select variate to start with 
  if (is.null(start)) {
    start = sample(x = 1:200, size = 1)
  } else {
    start = start
  }
  
  var = start
  dose = 1
  esc = 0
  mtd = 0
  
  while (esc == 0 && dose <= length(dlt)) {
    
    dlt.dose_3 = c()
    for (i in 1:coh.size) {
      s = i - 1
      dlt.dose_3[[i]] = qbinom(variates[[var + s]], 1, dlt[[dose]])
    }
    d3 = sum(dlt.dose_3)
    
    var = var + s + 1
    
    if (d3 == 0) {
      dose = dose + 1
    } else if (d3 > 1) {
      mtd = dose - 1
      esc = 1
    } else if (d3 == 1) {
      dlt.dose_6 = c()
      for (i in 1:coh.size) {
        s = i - 1
        dlt.dose_6[[i]] = qbinom(variates[[var + s]], 1, dlt[[dose]])
      }
      d6 = sum(dlt.dose_6)
      var = var + s + 1
      
      dlt_total = d3 + d6
      
      if (dlt_total == 1 ) {
        dose = dose + 1
      } else {
        mtd = dose - 1
        esc = 1
      }
    }
    
    if (dose >= length(dlt) && mtd == 0) {
      mtd = length(dlt)
    }
    
  }
  return(mtd)
  
}
```

```{r 5a}
unif_variates = c(
  0.007, 0.135, 0.772, 0.444, 0.287, 0.347, 0.777, 0.604, 0.025, 0.584,
  0.715, 0.110, 0.770, 0.405, 0.742, 0.923, 0.591, 0.567, 0.952, 0.039,
  0.342, 0.534, 0.342, 0.661, 0.829, 0.489, 0.710, 0.921, 0.055, 0.497,
  0.611, 0.118, 0.122, 0.472, 0.853, 0.931, 0.978, 0.232, 0.519, 0.333,
  0.096, 0.709, 0.985, 0.844, 0.948, 0.361, 0.061, 0.541, 0.815, 0.153,
  0.177, 0.495, 0.735, 0.872, 0.799, 0.028, 0.555, 0.763, 0.752, 0.682,
  0.228, 0.586, 0.732, 0.014, 0.753, 0.412, 0.765, 0.176, 0.919, 0.207,
  0.874, 0.178, 0.820, 0.783, 0.231, 0.541, 0.925, 0.207, 0.408, 0.808,
  0.434, 0.008, 0.382, 0.166, 0.328, 0.294, 0.635, 0.672, 0.669, 0.460,
  0.174, 0.374, 0.381, 0.600, 0.397, 0.091, 0.922, 0.872, 0.754, 0.520,
  0.977, 0.748, 0.955, 0.978, 0.531, 0.196, 0.963, 0.356, 0.061, 0.795,
  0.823, 0.731, 0.284, 0.929, 0.687, 0.858, 0.439, 0.944, 0.676, 0.189,
  0.755, 0.421, 0.357, 0.391, 0.370, 0.028, 0.866, 0.069, 0.818, 0.888,
  0.381, 0.989, 0.663, 0.491, 0.285, 0.000, 0.652, 0.341, 0.316, 0.599,
  0.977, 0.332, 0.985, 0.976, 0.695, 0.730, 0.580, 0.562, 0.674, 0.435,
  0.747, 0.521, 0.024, 0.412, 0.719, 0.819, 0.139, 0.278, 0.270, 0.877,
  0.431, 0.867, 0.723, 0.919, 0.244, 0.362, 0.442, 0.196, 0.409, 0.752,
  0.351, 0.979, 0.189, 0.523, 0.332, 0.690, 0.061, 0.552, 0.253, 0.450,
  0.403, 0.592, 0.381, 0.673, 0.182, 0.862, 0.223, 0.090, 0.729, 0.091,
  0.315, 0.763, 0.373, 0.174, 0.927, 0.264, 0.799, 0.653, 0.569, 0.109,
  0.706, 0.858, 0.357, 0.950, 0.801, 0.123, 0.019, 0.100, 0.329, 0.706,
  0.377, 0.993, 0.256, 0.964, 0.257, 0.778, 0.985, 0.849, 0.047, 0.650,
  0.932, 0.852, 0.750, 0.705, 0.965, 0.626, 0.821, 0.710, 0.988, 0.145,
  0.760, 0.296, 0.210, 0.944, 0.377, 0.880, 0.437, 0.847, 0.694, 0.069,
  0.139, 0.695, 0.444, 0.596, 0.725, 0.543, 0.580, 0.034, 0.899, 0.339
)

tox.rate = c(0.02, 0.04, 0.10, 0.25, 0.50)

variate_3plus3(coh.size = 3, dlt = tox.rate, variates = unif_variates, start = 1)
```

### (b)

```{r 5b}
set.seed(2)
var_sims = sapply(1:10, function(i){
  variate_3plus3(coh.size = 3, dlt = tox.rate, variates = unif_variates)
})
table(var_sims)
```


## Problem 6

```{r}
library(dfcrm)
target = 0.1
prior = c(0.05, 0.12, 0.25, 0.40, 0.55)
trueP = c(0.02, 0.04, 0.10, 0.25, 0.50)
N = 20
crmoutput = crmsim(trueP, prior, target, N, 3, model="logistic")
crmoutput$MTD
```

## Problem 7

```{r}
crm.sim = crmsim(PI = trueP, prior = prior, target = target, n = N, x0 = 3, nsim = 10)
crm.sim$MTD
```

## Problem 11

```{r ptw_a}
ptw = function(p_a, p_b, r_a, r_b, n) {
  
  # 1:1 randomization of first patient
  alloc = rbinom(1, 1, p_a)
  pts = c()
  outcome = c()
  
  for (i in 1:n) {
    
    # If allocated to treatment A
    if (alloc == 1) {
      o = rbinom(1, 1, r_a)
      pts[[i]] = 0
      
      # If success, stay on trt A, otherwise switch to trt B
      if (o == 1) {
        alloc = alloc
      } else {
        alloc = 0
      }
      
    # If allocated to trt B  
    } else {
      o = rbinom(1, 1, r_b)
      pts[[i]] = 1

      # If success, stay on trt B, otherwise switch to trt A
      if (o == 1) {
        alloc = alloc
      } else {
        alloc = 1
      }
      
    }
    outcome[[i]] = o
  }
  
  return(pts)
}

response.a = 0.2
response.b = 0.8
n.sim = 1e4

set.seed(1)
ptw_sims = lapply(1:n.sim, function(i){
  ptw(0.5, 0.5, response.a, response.b, 4)
})

prop.B.ptw = mean(sapply(ptw_sims, mean))

####

balanced_design = function(r_a, r_b, n){
  
  p_a = 0.5
  pts = c()
  outcome = c()
  
  for (i in 1:n) {
    
    # 1:1 randomization of first patient
    alloc = rbinom(1, 1, p_a)
    
    # If allocated to treatment A
    if (alloc == 1) {
      o = rbinom(1, 1, r_a)
      pts[[i]] = 0

    # If allocated to trt B  
    } else {
      o = rbinom(1, 1, r_b)
      pts[[i]] = 1
      
    }
    outcome[[i]] = o
  }
  
  return(pts)
  
}

set.seed(1)
balanced_sims = lapply(1:n.sim, function(i){
  balanced_design(response.a, response.b, 4)
})

prop.B.balanced = mean(sapply(balanced_sims, mean))



par(mfrow = c(1, 2))
hist(sapply(ptw_sims, sum), main = "Zelen's PTW", xlab = "Number of patients")
hist(sapply(balanced_sims, sum), main = "Balanced design", xlab = "Number of patients")
```

Using Zelen's play the winner rule, the first 4 patients are allocated to treatment B about `r round(prop.B.ptw*100, 0)`\% of the time, on average. The distribution of patients to treatment B is shown in the histogram above, where we give 3 out of 4 patients trt B. Meanwhile, the balanced design (1:1 randomization for all patients) allocates 2 patients to trt B on average (rate of `r round(prop.B.balanced, 2)`\%).

### b) 

```{r}
response.a = 0.3
response.b = 0.3
n.sim = 1e4

set.seed(1)
ptw_sims = lapply(1:n.sim, function(i){
  ptw(0.5, 0.5, response.a, response.b, 4)
})

prop.B.ptw = mean(sapply(ptw_sims, mean))

####

set.seed(1)
balanced_sims = lapply(1:n.sim, function(i){
  balanced_design(response.a, response.b, 4)
})

prop.B.balanced = mean(sapply(balanced_sims, mean))


par(mfrow = c(1, 2))
hist(sapply(ptw_sims, sum), main = "Zelen's PTW", xlab = "Number of patients")
hist(sapply(balanced_sims, sum), main = "Balanced design", xlab = "Number of patients")
```

When both treatments have the same response rate, the first 4 patients are allocated to treatment B about `r round(prop.B.ptw*100, 0)`\% of the time, on average. This allocation rate is about identical to the balanced design, however the actual distribution of number of patients varies between designs (see histograms). 

## Problem 12

```{r rptw}
rptw = function(r_a, r_b, n) {
  
  na = nb = 1
  pts = c()
  outcome = c()
  
  for (i in 1:n) {
    
    p_a = na/(na + nb)
    p_b = nb/(na + nb)
    
    # Randomize pt
    alloc = rbinom(1, 1, p_a)
    
    # If allocated to treatment A
    if (alloc == 1) {
      o = rbinom(1, 1, r_a)
      pts[[i]] = 0
      
      # If success, stay on trt A, otherwise switch to trt B
      if (o == 1) {
        na = na + 1
      } else {
        nb = nb + 1
      }
      
    # If allocated to trt B  
    } else {
      o = rbinom(1, 1, r_b)
      pts[[i]] = 1

      # If success, stay on trt B, otherwise switch to trt A
      if (o == 1) {
        nb = nb + 1
      } else {
        na = na + 1
      }
      
    }
    outcome[[i]] = o
  }
  
  return(pts)
}

response.a = 0.2
response.b = 0.8
n.sim = 1e4

set.seed(1)
rptw_sims = lapply(1:n.sim, function(i){
  rptw(response.a, response.b, 4)
})

prop.B = mean(sapply(rptw_sims, mean))

hist(sapply(rptw_sims, sum), main = "RPTW: Number of patients allocated to trt B under alternative", xlab = "Number of patients")

```


```{r}
response.a = 0.3
response.b = 0.3
n.sim = 1e4

set.seed(1)
rptw_sims = lapply(1:n.sim, function(i){
  rptw(response.a, response.b, 4)
})

prop.B = mean(sapply(rptw_sims, mean))

hist(sapply(rptw_sims, sum), main = "RPTW: Number of patients allocated to trt B under null", xlab = "Number of patients")
```

\pagebreak

